function clc_openPopup(name_of){	my = open (name_of, 'NamePopup2','toolbar=no,status=no,menubar=no,scrollbars=no,width=400,height=284');}			function clc_getElementByFieldName(strFieldName){	return document.all[strFieldName];}function clc_isAvailable(strFieldName){	if (clc_getElementByFieldName(strFieldName) === undefined)	{		return false;	}else{		return true;	}}function clc_validateSelectControl (strFieldName,intMax) {    var elm = clc_getElementByFieldName(strFieldName);    var iNumSelected = 0;    for (var iCount=0; elm.options[iCount]; iCount++) {        if (elm.options[iCount].selected == true) {            iNumSelected ++;        }    }    if (iNumSelected > intMax) {                return false;    }    return true;}function clc_getType(strFieldName){	return clc_getElementByFieldName(strFieldName).type;}function clc_getInnerTextById(strObjectID){	if(document.all)	{		if(document.getElementById && document.getElementById(strObjectID)) 		{				return document.getElementById(strObjectID).innerText;		}		else		{			return false;		}	}	else	{		if(document.getElementById && document.getElementById(strObjectID)) 		{				return document.getElementById(strObjectID).textContent;		}		else		{			return false;		}	}}function clc_getStyleByID(strObjectID) {	if(document.getElementById && document.getElementById(strObjectID)) 	{		return document.getElementById(strObjectID).style;	}	else if (document.all && document.all(strObjectID))	{		return document.all(strObjectID).style;	}	else if (document.layers && document.layers[strObjectID]) 	{		return document.layers[strObjectID];	}	else	{		return false;	}}function clc_changeVisibility(strObjectID, strNewVisibility){	var styleObject = clc_getStyleByID(strObjectID);	if(styleObject) 	{		styleObject.visibility = strNewVisibility;		return true;	}else{		return false;	}}function clc_isFieldRequired(strFieldName){	if(clc_getInnerTextById(strFieldName) == '*' || clc_getTextValue(strFieldName) == '*'){ // Check if the required field flag is still stored in a regular Notes/Domino field		return true;	}else{ // OK, it's neither		return false;	}}function clc_isFieldHidden(strFieldName) {	if(clc_getType(strFieldName) == "hidden")	{			return true;	}	else	{		return false;	}}function clc_isSelectEmpty(strFieldName) {	if (clc_getElementByFieldName(strFieldName).selectedIndex < 1)	{		return true;	}	else	{		return false;    	}}function clc_isTextEmpty(strFieldName) {	if(clc_trim(clc_getElementByFieldName(strFieldName).value) == "") 	{		return true;	}	else	{		return false;	}}function clc_getTextValue(strFieldName){	strValue = "";	var elm = clc_getElementByFieldName(strFieldName)		strValue = elm.value;		return strValue;}function clc_getRadioValue(strFieldName){	strValue = "";		var elm = clc_getElementByFieldName(strFieldName);		if(!elm[0])	{		if(elm.checked) 		{			strValue = elm.value;		}		}	else	{		for (i = 0; i < elm.length; i++) 		{					if(elm[i].checked) 			{				strValue = elm[i].value;				break;			}		}	}	return strValue;}function clc_getCheckValue(strFieldName){	var elm = clc_getElementByFieldName(strFieldName)		var strarrValues = new Array();	var i	var j = 0	for(i = 0; i < elm.length; i++)	{		if (elm[i].checked)		{			strarrValues[j] = elm[i].value			j++;		}	}		return strarrValues;}	function clc_getSelectValue(strFieldName){	strValue = "";		var elm = clc_getElementByFieldName(strFieldName);			if(elm.options)	{		intSelectedIndex = elm.selectedIndex;		if(elm.options[intSelectedIndex].value != '0')		{			strValue = elm.options[intSelectedIndex].text;			if ('Select' == strValue)			{				strValue = '';			}				}		else		{			strValue = '';			}		}	else	{		strValue = "";	}	return strValue;}function clc_resetSelect(strFieldName){	var elm = clc_getElementByFieldName(strFieldName);	elm.length = 0;}function clc_appendSelect(strFieldName, strText, strValue){	var elmOptNew = document.createElement('option');	elmOptNew.text = strText;	elmOptNew.value = strValue;	var elm = clc_getElementByFieldName(strFieldName);	try	{		elm.add(elmOptNew, null); // standards compliant; doesn't work in IE 	}	catch(e)	{		elm.add(elmOptNew); // IE only	}}function clc_isSelected(strFieldName){	elm = clc_getElementByFieldName(strFieldName)		for (var i = 0; i < elm.length; i++)	{		if (elm[i].checked) return true;	}}function clc_checkEmail(emailStr) {	/* The following variable tells the rest of the function whether or not	to verify that the address ends in a two-letter country or well-known	TLD.  1 means check it, 0 means don't. */	var checkTLD=1;	var knownDomsPat=/^(COM|NET|ORG|EDU|GOV|com|net|org|edu|int|mil|gov|arpa|biz|aero|name|coop|info|pro|museum|asia|ruhr|GLOBAL|global)$/;	var emailPat=/^(.+)@(.+)$/;	var specialChars="\\(\\)><@,;:\\\\\\\"\\.\\[\\]";	var validChars="\[^\\s" + specialChars + "\]";	var quotedUser="(\"[^\"]*\")";	var ipDomainPat=/^\[(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})\]$/;	var atom=validChars + '+';	var word="(" + atom + "|" + quotedUser + ")";	var userPat=new RegExp("^" + word + "(\\." + word + ")*$");	var domainPat=new RegExp("^" + atom + "(\\." + atom +")*$");	var matchArray=emailStr.match(emailPat);	var value="";	if (matchArray==null) {		value = "Email address seems incorrect (check @ and .'s)";		return value;	}	var user=matchArray[1];	var domain=matchArray[2];	// Start by checking that only basic ASCII characters are in the strings (0-127).	for (i=0; i<user.length; i++) {		if (user.charCodeAt(i)>127) {			value = "Ths username contains invalid characters.";			return value;	    }		}	for (i=0; i<domain.length; i++) {		if (domain.charCodeAt(i)>127) {			value = "Ths domain name contains invalid characters.";			return value;   		}	}	// See if "user" is valid 	if (user.match(userPat)==null) {		// user is not valid		value = "The username doesn't seem to be valid.";		return value;	}	/* if the e-mail address is at an IP address (as opposed to a symbolic	host name) make sure the IP address is valid. */	var IPArray=domain.match(ipDomainPat);	if (IPArray!=null) {		// this is an IP address		for (var i=1;i<=4;i++) {			if (IPArray[i]>255) {				value = "Destination IP address is invalid!";				return value;		   }		}		value = "yes";		return value;	}	// Domain is symbolic name.  Check if it's valid. 	var atomPat=new RegExp("^" + atom + "$");	var domArr=domain.split(".");	var len=domArr.length;	for (i=0;i<len;i++) {		if (domArr[i].search(atomPat)==-1) {			value = "The domain name does not seem to be valid.";			return value;   		}	}	/* domain name seems valid, but now make sure that it ends in a	known top-level domain (like com, edu, gov) or a two-letter word,	representing country (uk, nl), and that there's a hostname preceding 	the domain or country. */	if (checkTLD && domArr[domArr.length-1].length!=2 && 		domArr[domArr.length-1].search(knownDomsPat)==-1) {		value = "The address must end in a well-known domain or two letter " + "country.";		return value;	}	// Make sure there's a host name preceding the domain.	if (len<2) {		value = "This address is missing a hostname!";		return value;	}	// If we've gotten this far, everything's valid!	value = "yes";	return value;}function clc_ltrim(str){	for (var i = 0; i < str.length && str.charAt(i) == ' '; i++);     return str.substring(i);}function clc_rtrim(str){	for (var i = str.length; i > 0 && str.charAt(i - 1) == ' '; i--);     return str.substring(0, i);}function clc_trim(str){	return clc_ltrim(clc_rtrim(str));}